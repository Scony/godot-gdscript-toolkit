start: _class_stmt+

_class_stmt: (_simple_class_stmt _NL) | compound_class_stmt | _NL
_simple_class_stmt: single_class_stmt (";" single_class_stmt)* [";"]
?single_class_stmt: tool_stmt
                  | signal_stmt
                  | extends_stmt
                  | classname_stmt
                  | class_var_stmt
                  | const_stmt
                  | export_stmt
                  | onready_stmt
                  | docstr_stmt
?compound_class_stmt: class_def
                    | enum_def
                    | "static" func_def -> static_func_def
                    | "remote" func_def -> remote_func_def
                    | "remotesync" func_def -> remotesync_func_def
                    | "master" func_def -> master_func_def
                    | "puppet" func_def -> puppet_func_def
                    | "sync" func_def -> sync_func_def
                    | func_def

tool_stmt: "tool"
signal_stmt: "signal" NAME ["(" [NAME ("," NAME)* [trailing_comma]] ")"]
extends_stmt: "extends" (NAME | string ("." NAME)*)
classname_stmt: "class_name" NAME ["," string]
export_stmt: export_inf | export_typed
export_inf: "export" (var_assigned | var_typed | var_typed_assgnd | var_inf) [setget]
export_typed: "export" "(" TYPE ("," expr)* ")" class_var_stmt
class_var_stmt: _var_stmt [setget]
_var_stmt: var_empty
         | var_assigned
         | var_typed
         | var_typed_assgnd
         | var_inf
var_empty: "var" NAME
var_assigned: "var" NAME "=" expr
_var_typed: "var" NAME ":" TYPE
var_typed: _var_typed
var_typed_assgnd: _var_typed "=" expr
var_inf: "var" NAME ":=" expr
setget: "setget" [NAME] ["," NAME]
!const_stmt: "const" NAME [":" [TYPE]] "=" expr
onready_stmt: "onready" class_var_stmt
docstr_stmt: string

class_def: "class" NAME [extends_stmt] ":" (_class_body | _class_stmt)
_class_body: _NL _INDENT _class_stmt+ _DEDENT

func_def: "func" NAME "(" [func_args] ")" ["." _call_arglist] ["->" TYPE] ":" _func_suite
func_args: func_arg ("," func_arg)*
?func_arg: func_arg_regular
         | func_arg_inf
         | func_arg_typed
func_arg_regular: ["var"] NAME ["=" expr]
func_arg_inf: ["var"] NAME ":=" expr
func_arg_typed: ["var"] NAME ":" TYPE ["=" expr]
_func_suite: _func_body
           | func_stmt+
_func_body: _NL _INDENT func_stmt+ _DEDENT
?func_stmt: (simple_func_stmt _NL) | compound_func_stmt
?simple_func_stmt: single_func_stmt (";" single_func_stmt)* [";"]
?single_func_stmt: pass_stmt
                 | return_stmt
                 | func_var_stmt
                 | break_stmt
                 | continue_stmt
                 | expr_stmt
?compound_func_stmt: if_stmt
                   | while_stmt
                   | for_stmt
                   | match_stmt
pass_stmt: "pass"
return_stmt: "return" [expr]
func_var_stmt: _var_stmt
break_stmt.2: "break"
continue_stmt.2: "continue"
expr_stmt: expr
if_stmt: if_branch (_NL? elif_branch)* [_NL? else_branch]
if_branch: "if" expr ":" _func_suite
elif_branch: "elif" expr ":" _func_suite
else_branch: "else" ":" _func_suite
while_stmt: "while" expr ":" _func_suite
for_stmt: "for" NAME "in" expr ":" _func_suite
match_stmt: "match" expr ":" match_body
match_body: _NL _INDENT match_branch+ _DEDENT
match_branch: (expr | "_") ":" _NL _INDENT func_stmt+ _DEDENT // TODO: extend

enum_def: (enum_regular | enum_named) _NL
enum_regular: "enum" _enum_body
enum_named: "enum" NAME _enum_body
!_enum_body: "{" [enum_element ("," enum_element)* [","]] "}"
enum_element: NAME ["=" NUMBER]

expr: test_expr
    | assnmnt_expr
assnmnt_expr: attr_expr _assnmnt_op test_expr
!_assnmnt_op: "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|="
!?test_expr: or_test ["if" or_test "else" test_expr]
!?or_test: and_test (("or" | "||") and_test)*
!?and_test: not_test (("and" | "&&") not_test)*
!?not_test: ("not" | "!") not_test | content_test
!?content_test: comparison ("in" comparison)*
?comparison: bitw_or [_comp_op bitw_or]
!_comp_op: ">" | "<" | "==" | "!=" | "<=" | ">="
!?bitw_or: bitw_xor ("|" bitw_xor)*
!?bitw_xor: bitw_and ("^" bitw_and)*
!?bitw_and: shift_expr ("&" shift_expr)*
!?shift_expr: subtr_expr (("<<" | ">>") subtr_expr)*
!?subtr_expr: addn_expr ("-" addn_expr)*
!?addn_expr: mdr_expr ("+" mdr_expr)*
!?mdr_expr: neg_expr (("*" | "/" | "%") neg_expr)*
!?neg_expr: "-" neg_expr
          | bitw_not
!?bitw_not: "~" bitw_not
          | type_test
!?type_test: type_cast ("is" type_cast)*
!?type_cast: _call_expr ("as" TYPE)* // TODO: fix precedence (same as "is" probably(!))
_call_expr: standalone_call
          | getattr_call
          | attr_expr
!standalone_call: ["."] NAME _call_arglist
!getattr_call: getattr _call_arglist
!_call_arglist: "(" [test_expr ("," test_expr)*] ")"
!?attr_expr: getattr
           | subscr_expr
getattr: _call_expr _attr+
!_attr: ("." NAME)
?subscr_expr: _call_expr "[" test_expr "]"
            | atom
?atom: "(" test_expr ")" -> par_expr
     | array
     | dict
     | NAME
     | HEX
     | literal
?literal: NUMBER
        | string
        | node_path
        | get_node
HEX.2: /0x[a-fA-F0-9]+/
node_path: "@" string
get_node: "$" (path | string)
path: NAME ("/" NAME)*
array: "[" [test_expr ("," test_expr)* [trailing_comma]] "]"
trailing_comma: ","
dict: "{" [_kv_pair ("," _kv_pair)* [trailing_comma]] "}"
_kv_pair: (c_dict_element | eq_dict_element)
c_dict_element: test_expr ":" test_expr
eq_dict_element: NAME "=" test_expr

TYPE: NAME

string: LONG_STRING | REGULAR_STRING
REGULAR_STRING: /("(?!"").*?(?<!\\)(\\\\)*?"|'(?!'').*?(?<!\\)(\\\\)*?')/i
LONG_STRING: /""".*?(?<!\\)(\\\\)*?"""/is | /'''.*?(?<!\\)(\\\\)*?'''/is

_NL: ( /\r?\n[\t ]*/ | COMMENT )+
COMMENT: /#[^\n]*/
LINE_CONT: /\\[\t \f]*\r?\n/

%declare _INDENT _DEDENT

%ignore WS_INLINE
%ignore COMMENT
%ignore LINE_CONT

%import common.WS_INLINE
%import common.CNAME -> NAME
%import common.SIGNED_NUMBER -> NUMBER
